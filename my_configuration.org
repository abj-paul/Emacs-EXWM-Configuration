#+SEQ_TODO: THIS_IS_GOLD WILL_WORK_ON_IT | INCOMPLETE DONE
* THIS_IS_GOLD A DETAILED guide to elisp
[[https://www.math.utah.edu/docs/info/emacs-lisp-intro_toc.html][Perfect guide.]]
[[https://sachachua.com/blog/2014/04/emacs-beginner-resources/][Emacs guides by Sacha Sua]]
[[https://orgmode.org/worg/org-web.html][Sites made with org mode.]]
* Use-package
#+begin_src emacs-lisp
(setq use-package-always-ensure t)
#+end_src
* Installation
I will add my config file installation procedure once I am done with editing it and it works fine.
** Dependency
It will contain dependency list.
* Theme
** Doom 
#+begin_src emacs-lisp
(use-package doom-themes
  :init
  (load-theme 'doom-nord t))
#+end_src
** all-the-icons
Show icons. Doom modeline and counsel-M-x uses them.
#+begin_src emacs-lisp
(use-package all-the-icons)
; make icons look nice.
(all-the-icons-wicon "tornado" :face 'all-the-icons-blue)
#+end_src
** Doom Modeline
#+begin_src emacs-lisp
;(use-package doom-modeline
;  :init (doom-modeline-mode 1))
#+end_src
** Line Number

#+begin_src emacs-lisp
;(global-display-line-numbers-mode t)
;; Disable line numbers for some modes
;(dolist (mode '(;;org-mode-hook
;                org-agenda-mode-hook
;                term-mode-hook
;                shell-mode-hook
;                eshell-mode-hook
;                vterm-mode-hook
;                treemacs-mode-hook
;                compilation-mode-hook))
;  (add-hook mode (lambda () (display-line-numbers-mode 0))))
#+end_src
** Transparency
   Make emacs transparent.
#+begin_src emacs-lisp
(set-frame-parameter (selected-frame) 'alpha `(90,90))
(add-to-list 'default-frame-alist `(alpha . (90, 90)))
(set-frame-parameter (selected-frame) 'fullscreen 'maximized)
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src
** Looks
*** Highligh current line
=hl-line= is awesome! It's not very awesome in the terminal version of emacs though, so we don't use that.
Besides, it's only used for programming.
#+BEGIN_SRC emacs-lisp
  (when window-system (add-hook 'prog-mode-hook 'hl-line-mode))
#+END_SRC
*** Pretty symbols
Changes =lambda= to an actual symbol and a few others as well, only in the GUI version though.
#+BEGIN_SRC emacs-lisp
  (when window-system
        (use-package pretty-mode
        :ensure t
        :config
        (global-pretty-mode t)))
#+END_SRC
** Functionality
*** Async
    Lets us use asynchronous processes wherever possible, pretty useful. [[https://nullprogram.com/blog/2019/03/10/][Guide.]]
#+BEGIN_SRC emacs-lisp
  (use-package async
    :ensure t
    :init (dired-async-mode 1))
#+END_SRC
*** Projectile
It recognizes a directory with a git as a project. I should work with it sometimes.
*** Magit
its also a cool one, i should use it someday.
* System Settings
** Get rid of menu, fringe, sidebars etc
#+begin_src emacs-lisp
(setq inhibit-startup-message t) ;; Hide welcome buffer
(scroll-bar-mode -1)             ;; Disable visible scrollbar
(tool-bar-mode -1)               ;; Disable the toolbar
(tooltip-mode -1)                ;; Disable tooltips (pop-up help text for buttons and menu-items). When disabled shows tooltips in echo area
(set-fringe-mode 10)             ;; Set right and left edge fringes (empty borders) in px
(menu-bar-mode -1)               ;; Disable menu bar

(setq visible-bell t)            ;; Set up visible bell
#+end_src
** Mixup
#+begin_src emacs-lisp

;; Stop asking each time to execute code from babel blocks
(setq org-confirm-babel-evaluate nil)
(global-set-key "\C-ca" 'org-agenda)
#+end_src
** Toggle truncate lines
#+begin_src emacs-lisp
(global-visual-line-mode)
#+end_src
* Emacs Environment
** vterm
#+begin_src emacs-lisp

(use-package vterm)
;;(use-package vterm
;;  :commands (vterm)
;;  :ensure t
;;  :init
;;  (unless (file-exists-p (concat (file-name-directory (locate-library "vterm"))
;;                                 "vterm-module.so"))
;;    (message "Set vterm to install.")
;;    (setq vterm-install t)))
  
#+end_src
** counsel
It gives a nice gui in the minibuffer that comes from M-x.
#+begin_src emacs-lisp
(use-package counsel
  :config
  (counsel-mode 1))
#+end_src
** Ivy
counsel only works for M-x. But it does not provide gui for others like C-x-b(switch-buffer) etc.
Ivy rich adds function description in M-x.
--Keybindings:
1) C-j, C-k to navigate up-down
2) C-l can be used instead of pressing enter. Its recommended because l is right beside j ad k.
3) press C-X-b and C-d to delete a buffer.

#+begin_src emacs-lisp
(use-package ivy
  ;;  :diminish
  :bind (("C-s" . swiper)
         :map ivy-minibuffer-map
         ("C-l" . ivy-alt-done)
         ("C-j" . ivy-next-line)
         ("C-k" . ivy-previous-line)
         :map ivy-switch-buffer-map
         ("C-k" . ivy-previous-line)
         ("C-l" . ivy-done)
         ("C-d" . ivy-switch-buffer-kill)
         :map ivy-reverse-i-search-map
         ("C-k" . ivy-previous-line)
         ("C-d" . ivy-reverse-i-search-kill))
  :config
  (ivy-mode 1))

;; Show function descriptions and keybindings in counsel M-x and other buffers
(use-package ivy-rich
  :init
  (ivy-rich-mode 1))
  
#+end_src
** smex package
Provides sorted command history. Its automatically used by counsel-M-x so no need for extra customizations.
#+begin_src emacs-lisp
(use-package smex)
#+end_src
** Helpful
#+begin_src emacs-lisp
;; Enhance describe
(use-package helpful
  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable)
  :bind
  ([remap describe-function] . counsel-describe-function)
  ([remap describe-command] . helpful-command)
  ([remap describe-variable] . counsel-describe-variable)
  ([remap describe-key] . helpful-key))
#+end_src
** Which-key
#+begin_src emacs-lisp
(use-package which-key
  :config
  (setq which-key-idle-delay 0.4)
  (which-key-mode +1))
#+end_src
** Evil
--Keybindings
1) Use C-h as backspace in insert mode.
2) Use C-u to scroll up.
3) Use C-d to scroll down.
- disabled use of arrow keys
#+BEGIN_SRC emacs-lisp
(use-package evil
  :init
  (setq evil-want-integration t)
  (setq evil-want-keybinding nil)
  ;(setq evil-want-C-u-scroll t)
  (setq evil-want-C-i-jump nil)
  :config
  (evil-mode 1)
  (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
  (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)

  ;; Use visual line motions even outside of visual-line-mode buffers
  (evil-global-set-key 'motion "j" 'evil-next-visual-line)
  (evil-global-set-key 'motion "k" 'evil-previous-visual-line)
  
  (defun dw/dont-arrow-me-bro ()
  (interactive)
  (message "Arrow keys are bad, you know?"))

    ;; Disable arrow keys in normal and visual modes
    (define-key evil-normal-state-map (kbd "<left>") 'dw/dont-arrow-me-bro)
    (define-key evil-normal-state-map (kbd "<right>") 'dw/dont-arrow-me-bro)
    (define-key evil-normal-state-map (kbd "<down>") 'dw/dont-arrow-me-bro)
    (define-key evil-normal-state-map (kbd "<up>") 'dw/dont-arrow-me-bro)
    (evil-global-set-key 'motion (kbd "<left>") 'dw/dont-arrow-me-bro)
    (evil-global-set-key 'motion (kbd "<right>") 'dw/dont-arrow-me-bro)
    (evil-global-set-key 'motion (kbd "<down>") 'dw/dont-arrow-me-bro)
    (evil-global-set-key 'motion (kbd "<up>") 'dw/dont-arrow-me-bro)

  (evil-set-initial-state 'messages-buffer-mode 'normal)
  (evil-set-initial-state 'dashboard-mode 'normal))
#+END_SRC

#+RESULTS:
: t

** evil-collection
Evil keybinding for famous mode/packages like vterm, eshell etc.
#+begin_src emacs-lisp
(use-package evil-collection
  :after evil
  :config
  (evil-collection-init))
#+end_src
* Org mode
** Better Font Face
   The efs/org-font-setup function configures various text faces to tweak the sizes of headings and use variable width fonts in most cases so that it looks more like we’re editing a document in org-mode. We switch back to fixed width (monospace) fonts for code blocks and tables so that they display correctly.
*** code
#+BEGIN_SRC emacs-lisp
(defun efs/org-font-setup ()
;; Replace list hyphen with dot
(font-lock-add-keywords 'org-mode
'(("^ *\\([-]\\) "
(0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

;; Set faces for heading levels
(dolist (face '((org-level-1 . 1.2)
(org-level-2 . 1.1)
(org-level-3 . 1.05)
(org-level-4 . 1.0)
(org-level-5 . 1.1)
(org-level-6 . 1.1)
(org-level-7 . 1.1)
(org-level-8 . 1.1)))
(set-face-attribute (car face) nil :font "Cantarell" :weight 'regular :height (cdr face)))

;; Ensure that anything that should be fixed-pitch in Org files appears that way
(set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
(set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-table nil   :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch))
#+END_SRC

#+RESULTS:
: efs/org-font-setup

** Org Bullets With Some Tweaks
   org-bullets replaces the heading stars in org-mode buffers with nicer looking characters that you can control.
*** code
#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :after org
  :hook (org-mode . org-bullets-mode)
  :custom
  (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))
#+END_SRC

#+RESULTS:
| org-bullets-mode | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes |

** Center Org Files
We use visual-fill-column to center org-mode buffers for a more pleasing writing experience as it centers the contents of the buffer horizontally to seem more like you are editing a document. This is really a matter of personal preference so you can remove the block below if you don’t like the behavior.
*** code
#+BEGIN_SRC emacs-lisp
(defun efs/org-mode-visual-fill ()
  (setq visual-fill-column-width 100
        visual-fill-column-center-text t)
  (visual-fill-column-mode 1))

(use-package visual-fill-column
  :hook (org-mode . efs/org-mode-visual-fill))
#+END_SRC
* Development Environment
** Additional Packages
This section contains packages that is universally needed by many programming languages.
*** Hungry Delete
#+begin_src emacs-lisp
(use-package hungry-delete)
#+end_src
** Java
 #+begin_src emacs-lisp
 (use-package projectile)
 (use-package flycheck)
 (use-package yasnippet :config (yas-global-mode))
 (use-package lsp-mode :hook ((lsp-mode . lsp-enable-which-key-integration))
   :config (setq lsp-completion-enable-additional-text-edit nil))
 (use-package hydra)
 (use-package company)
 (use-package lsp-ui)
 (use-package which-key :config (which-key-mode))
 (use-package lsp-java :config (add-hook 'java-mode-hook 'lsp))
 (use-package dap-mode :after lsp-mode :config (dap-auto-configure-mode))
 (use-package dap-java :ensure nil)
 (use-package lsp-ivy)
 (use-package lsp-treemacs)
 #+end_src

 #+RESULTS:
* Custom-Made Functions
All the custom made functions are here so that they initialize before exwm (thats where we use them, mainly)
** Start-up window with dashboard and schedeule
 #+begin_src emacs-lisp
 ;(progn 
 ;    (find-file "~/Desktop/Everything/Emacs/Daily-Routine.org" )
 ;    (split-window-horizontally)
 ;    (dashboard-refresh-buffer)
 ;)
 ;; Adding this function to exwm
 (defun abj/startup-window()
   "Open dashboard and Daily-Routine.org in startup window."
   (interactive)
   (exwm-workspace-switch-create 1)
   (find-file "~/Desktop/Everything/Emacs/Daily-Routine.org" )
   (split-window-horizontally)
   ;(dashboard-setup-startup-hook)
   ;(dashboard-refresh-buffer)
   (find-file "~/Desktop/Everything/Emacs/Steps.org" )
 )
 #+end_src
** Bind buffer to workspace
 #+begin_src emacs-lisp
 (defun abj/bind-vterm-to-workspace(workspace-index buffer-name dir)
   "Bind a buffer to a workspace in EXWM"
   (interactive)
   (exwm-workspace-switch-create workspace-index)
   (multi-vterm)
   (let ((default-buffer-name "*vterminal<1>*"))
   (progn
   (comint-send-string (get-buffer-process default-buffer-name) (format "cd %s\n" dir))
   (with-current-buffer default-buffer-name
     (rename-buffer buffer-name))
     ))
     )
 (defun abj/firefox-buffer()
 "Opens firefox in workspace 4 at startup"
   (interactive)
   (exwm-workspace-switch-create 4)
   (start-process-shell-command "firefox" "global-firefox" "firefox")
)
(defun abj/dashboard-buffer()
 "Opens dashboard in workspace 3 at startup"
 (interactive)
 (exwm-workspace-switch-create 3)
 (dashboard-setup-startup-hook)
 (dashboard-refresh-buffer)
 )

 (defun abj/init-workspace-bounded-buffers()
   "Initializes buffers in workspaces"
   (interactive)
   ;(setq exwm-workspace-number 7l)
   (abj/dashboard-buffer)
   (abj/bind-vterm-to-workspace 2 "project-vterm" "~/Desktop/Everything/")
   (abj/bind-vterm-to-workspace 5 "others-vterm" "~/.emacs.d/")
   (abj/firefox-buffer)
   (abj/startup-window)
   (exwm-workspace-switch 1)
 )
 ;(bind-buffer-to-workspace)
 #+end_src
* Window Manager(EXWM)
Everything regarding the WM or DE-like functionality is bundled here, remove the entire section if you do not wish to use =exwm=.

** exwm
   The only time I actually had to use comments, this is for ease of removal if you happen to not like exwm.
*** Installation
#+BEGIN_SRC emacs-lisp
(defun efs/set-wallpaper ()
    (interactive)
    ;; NOTE: You will need to update this to a valid background path!
    (start-process-shell-command
        "feh" nil  "feh --bg-scale /usr/share/backgrounds/derrick-cooper-L505cPnmIds-unsplash.jpg"))
  (defun efs/configure-window-by-class ()
    (interactive)
    (pcase exwm-class-name
      ;("Firefox" (exwm-workspace-move-window 2))
      ("Sol" (exwm-workspace-move-window 3))
      ("mpv" (exwm-floating-toggle-floating)
             (exwm-layout-toggle-mode-line))))
  (defun efs/exwm-update-class ()
    (exwm-workspace-rename-buffer exwm-class-name))

  (defun efs/exwm-update-title ()
    (pcase exwm-class-name
      ("Firefox" (exwm-workspace-rename-buffer (format "Firefox: %s" exwm-title)))))


  (use-package exwm
    :ensure t
    :config
      ;; necessary to configure exwm manually
      (require 'exwm-config)

      ;; fringe size, most people prefer 1 
      (fringe-mode 3)
      
      ;; emacs as a daemon, use "emacsclient <filename>" to seamlessly edit files from the terminal directly in the exwm instance
      (server-start)
      ;; Transparency
      (set-frame-parameter (selected-frame) 'alpha `(90,90))
      (add-to-list 'default-frame-alist `(alpha . (90, 90)))
      (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
      (add-to-list 'default-frame-alist '(fullscreen . maximized))

      ;; this fixes issues with ido mode, if you use helm, get rid of it
      ;(exwm-config-ido)
      (efs/set-wallpaper)
      
;; a number between 1 and 9, exwm creates workspaces dynamically so I like starting out with 1
      ;(setq exwm-workspace-number 6)

      ;; When window "class" updates, use it to set the buffer name
      (add-hook 'exwm-update-class-hook #'efs/exwm-update-class)
            
      ;; When window title updates, use it to set the buffer name
      (add-hook 'exwm-update-title-hook #'efs/exwm-update-title)

      ;; Configure windows as they're created
      (add-hook 'exwm-manage-finish-hook #'efs/configure-window-by-class)

      ;; Trying to make workspaces load faster.
      ;(exwm-workspace-switch-create 0)
      ;; this is a way to declare truly global/always working keybindings
      ;; this is a nifty way to go back from char mode to line mode without using the mouse
      (exwm-input-set-key (kbd "s-r") #'exwm-reset)
      (exwm-input-set-key (kbd "s-k") #'exwm-workspace-delete)
      (exwm-input-set-key (kbd "s-w") #'exwm-workspace-swap)

      ;; the next loop will bind s-<number> to switch to the corresponding workspace
      (dotimes (i 10)
        (exwm-input-set-key (kbd (format "s-%d" i))
                            `(lambda ()
                               (interactive)
                               (exwm-workspace-switch-create ,i))))

      ;; the simplest launcher, I keep it in only if dmenu eventually stopped working or something
      (exwm-input-set-key (kbd "s-&")
                          (lambda (command)
                            (interactive (list (read-shell-command "$ ")))
                            (start-process-shell-command command nil command)))

      ;; an easy way to make keybindings work *only* in line mode
      (push ?\C-q exwm-input-prefix-keys)
      (define-key exwm-mode-map [?\C-q] #'exwm-input-send-next-key)
      
      (setq exwm-input-global-keys
      `(;; Various other keys...
      
      ;; Prompt for a selection and take a screenshot
        (,(kbd "s-$") . md/screenshot-image-selection)
        ;; Prompt for a selectoin and start a video
        (,(kbd "s-%") . md/screenshot-video-selection-start)
        ;; Stop the video
        (,(kbd "s-^") . md/screenshot-video-stop)))
	
      ;; simulation keys are keys that exwm will send to the exwm buffer upon inputting a key combination
      (exwm-input-set-simulation-keys
       '(
         ;; movement
         ;([?\C-b] . left)
         ;([?\M-b] . C-left)
         ;([?\C-f] . right)
         ;([?\M-f] . C-right)
         ;([?\C-p] . up)
         ;([?\C-n] . down)
         ;([?\C-a] . home)
         ;([?\C-e] . end)
         ;([?\M-v] . prior)
         ;([?\C-v] . next)
         ;([?\C-d] . delete)
         ;([?\C-k] . (S-end delete))
         ;; cut/paste
         ;([?\C-w] . ?\C-x)
         ([?\M-w] . ?\C-c)
         ;([?\C-y] . ?\C-v)
         ;; search
         ([?\C-s] . ?\C-f)))

     ;; These keys should always pass through to Emacs

      ;; this little bit will make sure that XF86 keys work in exwm buffers as well
      (dolist (k '(XF86AudioLowerVolume
                 XF86AudioRaiseVolume
                 XF86PowerOff
                 XF86AudioMute
                 XF86AudioPlay
                 XF86AudioStop
                 XF86AudioPrev
                 XF86AudioNext
                 XF86ScreenSaver
                 XF68Back
                 XF86Forward
                 Scroll_Lock
                 print))
      (cl-pushnew k exwm-input-prefix-keys))
      
      ;; this just enables exwm, it started automatically once everything is ready

      (exwm-enable)
      (abj/init-workspace-bounded-buffers)
)

#+END_SRC

#+RESULTS:
: t

** Launchers
Since I do not use a GUI launcher and do not have an external one like dmenu or rofi,
I figured the best way to launch my most used applications would be direct emacsy
keybindings.

*** dmenu for emacs
Who would've thought this was available, together with ido-vertical it's a nice large menu
with its own cache for most launched applications.
#+BEGIN_SRC emacs-lisp
  (use-package dmenu
    :ensure t
    :bind
      ("s-SPC" . 'dmenu))
#+END_SRC

*** Functions to start processes
I guess this goes without saying but you absolutely have to change the arguments
to suit the software that you are using. What good is a launcher for discord if you don't use it at all.
#+BEGIN_SRC emacs-lisp
  (defun exwm-async-run (name)
    (interactive)
    (start-process name nil name))

  (defun daedreth/launch-discord ()
    (interactive)
    (exwm-async-run "discord"))

  (defun daedreth/launch-browser ()
    (interactive)
    (exwm-async-run "qutebrowser"))

  (defun daedreth/lock-screen ()
    (interactive)
    (exwm-async-run "slock"))

  (defun daedreth/shutdown ()
    (interactive)
    (start-process "halt" nil "sudo" "halt"))
#+END_SRC

*** Keybindings to start processes
These can be modified as well, suit yourself.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-d") 'daedreth/launch-discord)
  (global-set-key (kbd "<s-tab>") 'daedreth/launch-browser)
  (global-set-key (kbd "s-l") 'daedreth/lock-screen)
  (global-set-key (kbd "<XF86PowerOff>") 'daedreth/shutdown)
#+END_SRC

** Audio controls
This is a set of bindings to my XF86 keys that invokes pulsemixer with the correct parameters

*** Volume modifier
It goes without saying that you are free to modify the modifier as you see fit, 4 is good enough for me though.
#+BEGIN_SRC emacs-lisp
(defconst volumeModifier "4")
#+END_SRC

*** Functions to start processes
#+BEGIN_SRC emacs-lisp
  (defun audio/mute ()
    (interactive)
    (start-process "audio-mute" nil "pulsemixer" "--toggle-mute"))

  (defun audio/raise-volume ()
    (interactive)
    (start-process "raise-volume" nil "pulsemixer" "--change-volume" (concat "+" volumeModifier)))

  (defun audio/lower-volume ()
    (interactive)
    (start-process "lower-volume" nil "pulsemixer" "--change-volume" (concat "-" volumeModifier)))
#+END_SRC

*** Keybindings to start processes
You can also change those if you'd like, but I highly recommend keeping 'em the same, chances are, they will just work.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<XF86AudioMute>") 'audio/mute)
(global-set-key (kbd "<XF86AudioRaiseVolume>") 'audio/raise-volume)
(global-set-key (kbd "<XF86AudioLowerVolume>") 'audio/lower-volume)
#+END_SRC

** Screenshots
I don't need scrot to take screenshots, or shutter or whatever tools you might have. This is enough.
These won't work in the terminal version or the virtual console, obvious reasons.
// NOT WORKING FOR ME.

*** Screenshotting the entire screen
#+BEGIN_SRC emacs-lisp
  (defun daedreth/take-screenshot ()
    "Takes a fullscreen screenshot of the current workspace"
    (interactive)
    (when window-system
    (loop for i downfrom 3 to 1 do
          (progn
            (message (concat (number-to-string i) "..."))
            (sit-for 1)))
    (message "Cheese!")
    (sit-for 1)
    (start-process "screenshot" nil "import" "-window" "root" 
               (concat (getenv "HOME") "/" (subseq (number-to-string (float-time)) 0 10) ".png"))
    (message "Screenshot taken!")))
  (global-set-key (kbd "<print>") 'daedreth/take-screenshot)
#+END_SRC

#+RESULTS:
: daedreth/take-screenshot

*** Screenshotting a region
#+BEGIN_SRC emacs-lisp
  (defun daedreth/take-screenshot-region ()
    "Takes a screenshot of a region selected by the user."
    (interactive)
    (when window-system
    (call-process "import" nil nil nil ".newScreen.png")
    (call-process "convert" nil nil nil ".newScreen.png" "-shave" "1x1"
                  (concat (getenv "HOME") "/" (subseq (number-to-string (float-time)) 0 10) ".png"))
    (call-process "rm" nil nil nil ".newScreen.png")))
  (global-set-key (kbd "<Scroll_Lock>") 'daedreth/take-screenshot-region)
#+END_SRC

** Default browser
I use qutebrowser, so that's what I'll set up.
#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "firefox")
#+END_SRC
* Dashboard
I should use it as a side window along with schedeules to make sure i keep tract of current projects.
This is your new startup screen, together with projectile it works in unison and
provides you with a quick look into your latest projects and files.
Change the welcome message to whatever string you want and
change the numbers to suit your liking, I find 5 to be enough.
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :ensure t
    :config
      (dashboard-setup-startup-hook)
      ;;(setq dashboard-startup-banner "~/.emacs.d/img/dashLogo.png")
      (setq dashboard-items '((recents  . 5)
                              (projects . 5)))
      (setq dashboard-banner-logo-title "")
      )
#+END_SRC
* Modeline
The modeline is the heart of emacs, it offers information at all times, it's persistent
and verbose enough to gain a full understanding of modes and states you are in.


Due to the fact that we attempt to use emacs as a desktop environment replacement,
and external bar showing the time, the battery percentage and more system info would be great to have.
I have however abandoned polybar in favor of a heavily modified modeline, this offers me more space
on the screen and better integration.


One modeline-related setting that is missing and is instead placed at the bottom is =diminish=.
** Spaceline!
I may not use spacemacs, since I do not like evil-mode and find spacemacs incredibly bloated and slow,
however it would be stupid not to acknowledge the best parts about it, the theme and their modified powerline setup.

This enables spaceline, it looks better and works very well with my theme of choice.
#+BEGIN_SRC emacs-lisp
  (use-package spaceline
    :ensure t
    :config
    (require 'spaceline-config)
      (setq spaceline-buffer-encoding-abbrev-p nil)
      (setq spaceline-line-column-p nil)
      (setq spaceline-line-p nil)
      (setq powerline-default-separator (quote arrow))
      (spaceline-spacemacs-theme))
#+END_SRC

** No separator!
#+BEGIN_SRC emacs-lisp
  (setq powerline-default-separator nil)
#+END_SRC

** Cursor position
Show the current line and column for your cursor.
We are not going to have =relative-linum-mode= in every major mode, so this is useful.
#+BEGIN_SRC emacs-lisp
  (setq line-number-mode t)
  (setq column-number-mode t)
#+END_SRC

** Clock
If you prefer the 12hr-format, change the variable to =nil= instead of =t=.

*** Time format
#+BEGIN_SRC emacs-lisp
  (setq display-time-24hr-format nil)
  (setq display-time-format "%H:%M - %d %B %Y")
#+END_SRC

*** Enabling the mode
This turns on the clock globally.
#+BEGIN_SRC emacs-lisp
  (display-time-mode 1)
#+END_SRC

** Battery indicator
A package called =fancy-battery= will be used if we are in GUI emacs, otherwise the built in battery-mode will be used.
Fancy battery has very odd colors if used in the tty, hence us disabling it.
#+BEGIN_SRC emacs-lisp
  (use-package fancy-battery
    :ensure t
    :config
      (setq fancy-battery-show-percentage t)
      (setq battery-update-interval 15)
      (if window-system
        (fancy-battery-mode)
        (display-battery-mode)))
#+END_SRC

** System monitor
A teeny-tiny system monitor that can be enabled or disabled at runtime, useful for checking performance
with power-hungry processes in ansi-term

symon can be toggled on and off with =Super + h=.
#+BEGIN_SRC emacs-lisp
  (use-package symon
    :ensure t
    :bind
    ("s-h" . symon-mode))
#+END_SRC
* The terminal
I have used urxvt for years, and I miss it sometimes, but ansi-term is enough for most of my tasks.

** Default shell should be bash
I don't know why this is a thing, but asking me what shell to launch every single
time I open a terminal makes me want to slap babies, this gets rid of it.
This goes without saying but you can replace bash with your shell of choice.
#+BEGIN_SRC emacs-lisp
  (defvar my-term-shell "/bin/bash")
  (defadvice ansi-term (before force-bash)
    (interactive (list my-term-shell)))
  (ad-activate 'ansi-term)
#+END_SRC

** Easy to remember keybinding
In loving memory of bspwm, Super + Enter opens a new terminal, old habits die hard.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<s-return>") 'ansi-term)
#+END_SRC
* Moving around emacs
One of the most important things about a text editor is how efficient you manage
to be when using it, how much time do basic tasks take you and so on and so forth.
One of those tasks is moving around files and buffers, whatever you may use emacs for
you /will/ be jumping around buffers like it's serious business, the following
set of enhancements aims to make it easier.

As a great emacs user once said:

#+BEGIN_QUOTE
Do me the favor, do me the biggest favor, matter of fact do yourself the biggest favor and integrate those into your workflow.
#+END_QUOTE

** a prerequisite for others packages
#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :ensure t)
#+END_SRC

** scrolling and why does the screen move
I don't know to be honest, but this little bit of code makes scrolling with emacs a lot nicer.
#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 100)
#+END_SRC

** which-key and why I love emacs
In order to use emacs, you don't need to know how to use emacs.
It's self documenting, and coupled with this insanely useful package, it's even easier.
In short, after you start the input of a command and stop, pondering what key must follow,
it will automatically open a non-intrusive buffer at the bottom of the screen offering
you suggestions for completing the command, that's it, nothing else.

It's beautiful
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :config
      (which-key-mode))
#+END_SRC

** windows,panes and why I hate other-window
Some of us have large displays, others have tiny netbook screens, but regardless of your hardware
you probably use more than 2 panes/windows at times, cycling through all of them with
=C-c o= is annoying to say the least, it's a lot of keystrokes and takes time, time you could spend doing something more productive.

*** switch-window
This magnificent package takes care of this issue.
It's unnoticeable if you have <3 panes open, but with 3 or more, upon pressing =C-x o=
you will notice how your buffers turn a solid color and each buffer is asigned a letter
(the list below shows the letters, you can modify them to suit your liking), upon pressing
a letter asigned to a window, your will be taken to said window, easy to remember, quick to use
and most importantly, it annihilates a big issue I had with emacs. An alternative is =ace-window=,
however by default it also changes the behaviour of =C-x o= even if only 2 windows are open,
this is bad, it also works less well with =exwm= for some reason.
#+BEGIN_SRC emacs-lisp
(use-package switch-window
  :ensure t
  :config
    (setq switch-window-input-style 'minibuffer)
    (setq switch-window-increase 4)
    (setq switch-window-threshold 2)
    (setq switch-window-shortcut-style 'qwerty)
    (setq switch-window-qwerty-shortcuts
        '("a" "s" "d" "f" "j" "k" "l" "i" "o"))
  :bind
    ([remap other-window] . switch-window))
#+END_SRC

*** Following window splits
After you split a window, your focus remains in the previous one.
This annoyed me so much I wrote these two, they take care of it.
#+BEGIN_SRC emacs-lisp
  (defun split-and-follow-horizontally ()
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

  (defun split-and-follow-vertically ()
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC

** swiper and why is the default search so lame
I like me some searching, the default search is very meh. In emacs, you mostly use search to get around your buffer, much like with avy, but sometimes it doesn't hurt to search for entire words or mode, swiper makes sure this is more efficient.
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :bind ("C-s" . 'swiper))
#+END_SRC

** buffers and why I hate list-buffers
Another big thing is, buffers. If you use emacs, you use buffers, everyone loves them.
Having many buffers is useful, but can be tedious to work with, let us see how we can improve it.

*** Always murder current buffer
Doing =C-x k= should kill the current buffer at all times, we have =ibuffer= for more sophisticated thing.
#+BEGIN_SRC emacs-lisp
  (defun kill-current-buffer ()
    "Kills the current buffer."
    (interactive)
    (kill-buffer (current-buffer)))
  (global-set-key (kbd "C-x k") 'kill-current-buffer)
#+END_SRC

*** Kill buffers without asking for confirmation
Unless you have the muscle memory, I recommend omitting this bit, as you may lose progress for no reason when working.
#+BEGIN_SRC emacs-lisp
;(setq kill-buffer-query-functions (delq 'process-kill-buffer-query-function kill-buffer-query-functions))
#+END_SRC

*** Turn switch-to-buffer into ibuffer
I don't understand how ibuffer isn't the default option by now.
It's vastly superior in terms of ergonomics and functionality, you can delete buffers, rename buffer, move buffers, organize buffers etc.
#+BEGIN_SRC emacs-lisp
;(global-set-key (kbd "C-x b") 'ibuffer)
#+END_SRC

**** expert-mode
If you feel like you know how ibuffer works and need not to be asked for confirmation after every serious command, enable this as follows.
#+BEGIN_SRC emacs-lisp
(setq ibuffer-expert t)
#+END_SRC
*** close-all-buffers
It's one of those things where I genuinely have to wonder why there is no built in functionality for it.
Once in a blue moon I need to kill all buffers, and having ~150 of them open would mean I'd need to spend a few too many
seconds doing this than I'd like, here's a solution.

This can be invoked using =C-M-s-k=. This keybinding makes sure you don't hit it unless you really want to.
#+BEGIN_SRC emacs-lisp
  (defun close-all-buffers ()
    "Kill all buffers without regard for their origin."
    (interactive)
    (mapc 'kill-buffer (buffer-list)))
  (global-set-key (kbd "C-M-s-k") 'close-all-buffers)
#+END_SRC

** line numbers and programming
Every now and then all of us feel the urge to be productive and write some code.
In the event that this happens, the following bit of configuration makes sure that 
we have access to relative line numbering in programming-related modes.
I highly recommend not enabling =linum-relative-mode= globally, as it messed up 
something like =ansi-term= for instance.
#+begin_src emacs-lisp :eval never-export :results none :exports none
  (use-package linum-relative
    :ensure t
    :config
      (setq linum-relative-current-symbol "")
      (add-hook 'prog-mode-hook 'linum-relative-mode))
#+END_SRC
* Minor conveniences
Emacs is at it's best when it just does things for you, shows you the way, guides you so to speak.
This can be best achieved using a number of small extensions. While on their own they might not be particularly
impressive. Together they create a nice environment for you to work in.

** Visiting the configuration
Quickly edit =~/.emacs.d/config.org=
#+BEGIN_SRC emacs-lisp
  (defun config-visit ()
    (interactive)
    (find-file "~/.emacs.d/config.org"))
  (global-set-key (kbd "C-c e") 'config-visit)
#+END_SRC

** Reloading the configuration
   
Simply pressing =Control-c r= will reload this file, very handy.
You can also manually invoke =config-reload=.
#+BEGIN_SRC emacs-lisp
  (defun config-reload ()
    "Reloads ~/.emacs.d/config.org at runtime"
    (interactive)
    (org-babel-load-file (expand-file-name "~/.emacs.d/my_configuration.org")))
  (global-set-key (kbd "C-c s-r") 'config-reload)
#+END_SRC

** Subwords
Emacs treats camelCase strings as a single word by default, this changes said behaviour.
#+BEGIN_SRC emacs-lisp
  (global-subword-mode 1)
#+END_SRC

** Electric
If you write any code, you may enjoy this.
Typing the first character in a set of 2, completes the second one after your cursor.
Opening a bracket? It's closed for you already. Quoting something? It's closed for you already.

You can easily add and remove pairs yourself, have a look.
#+BEGIN_SRC emacs-lisp
(setq electric-pair-pairs '(
                           (?\{ . ?\})
                           (?\( . ?\))
                           (?\[ . ?\])
                           (?\" . ?\")
                           ))
#+END_SRC

And now to enable it
#+BEGIN_SRC emacs-lisp
(electric-pair-mode t)
#+END_SRC

** Beacon
While changing buffers or workspaces, the first thing you do is look for your cursor.
Unless you know its position, you can not move it efficiently. Every time you change
buffers, the current position of your cursor will be briefly highlighted now.
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :config
      (beacon-mode 1))
#+END_SRC

** Rainbow
Mostly useful if you are into web development or game development.
Every time emacs encounters a hexadecimal code that resembles a color, it will automatically highlight
it in the appropriate color. This is a lot cooler than you may think.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :init
      (add-hook 'prog-mode-hook 'rainbow-mode))
#+END_SRC

** Show parens
I forgot about that initially, it highlights matching parens when the cursor is just behind one of them.
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC
** Rainbow delimiters
Colors parentheses and other delimiters depending on their depth, useful for any language using them,
especially lisp.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :init
      (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

** Expand region
A pretty simple package, takes your cursor and semantically expands the region, so words, sentences, maybe the contents of some parentheses, it's awesome, try it out.
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind ("C-q" . er/expand-region))
#+END_SRC
* Kill ring
There is a lot of customization to the kill ring, and while I have not used it much before,
I decided that it was time to change that.
** Maximum entries on the ring
The default is 60, I personally need more sometimes.
#+BEGIN_SRC emacs-lisp
  (setq kill-ring-max 100)
#+END_SRC

** popup-kill-ring
Out of all the packages I tried out, this one, being the simplest, appealed to me most.
With a simple M-y you can now browse your kill-ring like browsing autocompletion items.
C-n and C-p totally work for this.
#+BEGIN_SRC emacs-lisp
  (use-package popup-kill-ring
    :ensure t
    :bind ("M-y" . popup-kill-ring))
#+END_SRC
* Programming
Minor, non-completion related settings and plugins for writing code.

** yasnippet
#+BEGIN_SRC emacs-lisp
    (use-package yasnippet
      :ensure t
      :config
        (use-package yasnippet-snippets
          :ensure t)
        (yas-reload-all))
#+END_SRC

** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t)
#+END_SRC

** company mode
I set the delay for company mode to kick in to half a second, I also make sure that
it starts doing its magic after typing in only 2 characters.

I prefer =C-n= and =C-p= to move around the items, so I remap those accordingly.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :config
    (setq company-idle-delay 0)
    (setq company-minimum-prefix-length 3))

  (with-eval-after-load 'company
    (define-key company-active-map (kbd "M-n") nil)
    (define-key company-active-map (kbd "M-p") nil)
    (define-key company-active-map (kbd "C-n") #'company-select-next)
    (define-key company-active-map (kbd "C-p") #'company-select-previous)
    (define-key company-active-map (kbd "SPC") #'company-abort))
#+END_SRC

** specific languages
Be it for code or prose, completion is a must.
After messing around with =auto-completion= and =company= for a while I decided to .. use both?
AC is for Lua/LÖVE and Company for the rest.

Each category also has additional settings.

*** c/c++
#+BEGIN_SRC emacs-lisp
  (add-hook 'c++-mode-hook 'yas-minor-mode)
  (add-hook 'c-mode-hook 'yas-minor-mode)

  (use-package flycheck-clang-analyzer
    :ensure t
    :config
    (with-eval-after-load 'flycheck
      (require 'flycheck-clang-analyzer)
       (flycheck-clang-analyzer-setup)))

  (with-eval-after-load 'company
    (add-hook 'c++-mode-hook 'company-mode)
    (add-hook 'c-mode-hook 'company-mode))

  (use-package company-c-headers
    :ensure t)

  (use-package company-irony
    :ensure t
    :config
    (setq company-backends '((company-c-headers
                              company-dabbrev-code
                              company-irony))))

  (use-package irony
    :ensure t
    :config
    (add-hook 'c++-mode-hook 'irony-mode)
    (add-hook 'c-mode-hook 'irony-mode)
    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))
#+END_SRC

*** python
#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook 'yas-minor-mode)
  (add-hook 'python-mode-hook 'flycheck-mode)

  (with-eval-after-load 'company
      (add-hook 'python-mode-hook 'company-mode))

  (use-package company-jedi
    :ensure t
    :config
      (require 'company)
      (add-to-list 'company-backends 'company-jedi))

  (defun python-mode-company-init ()
    (setq-local company-backends '((company-jedi
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-jedi
    :ensure t
    :config
      (require 'company)
      (add-hook 'python-mode-hook 'python-mode-company-init))
#+END_SRC

*** emacs-lisp
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
  (add-hook 'emacs-lisp-mode-hook 'yas-minor-mode)
  (add-hook 'emacs-lisp-mode-hook 'company-mode)

  (use-package slime
    :ensure t
    :config
    (setq inferior-lisp-program "/usr/bin/sbcl")
    (setq slime-contribs '(slime-fancy)))

  (use-package slime-company
    :ensure t
    :init
      (require 'company)
      (slime-setup '(slime-fancy slime-company)))
#+END_SRC

*** bash
#+BEGIN_SRC emacs-lisp
  (add-hook 'shell-mode-hook 'yas-minor-mode)
  (add-hook 'shell-mode-hook 'flycheck-mode)
  (add-hook 'shell-mode-hook 'company-mode)

  (defun shell-mode-company-init ()
    (setq-local company-backends '((company-shell
                                    company-shell-env
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-shell
    :ensure t
    :config
      (require 'company)
      (add-hook 'shell-mode-hook 'shell-mode-company-init))
#+END_SRC
* Remote editing
I have no need to directly edit files over SSH, but what I do need is a way to edit files as root.
Opening up nano in a terminal as root to play around with grubs default settings is a no-no, this solves that.

** Editing with sudo
Pretty self-explanatory, useful as hell if you use exwm.
#+BEGIN_SRC emacs-lisp
  (use-package sudo-edit
    :ensure t
    :bind
      ("s-e" . sudo-edit))
#+END_SRC
* Diminishing modes
Your modeline is sacred, and if you have a lot of modes enabled, as you will if you use this config,
you might end up with a lot of clutter there, the package =diminish= disables modes on the mode line but keeps
them running, it just prevents them from showing up and taking up space.

*THIS WILL BE REMOVED SOON AS USE-PACKAGE HAS THE FUNCTIONALITY BUILT IN*

Edit this list as you see fit!
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :ensure t
    :init
    (diminish 'which-key-mode)
    (diminish 'linum-relative-mode)
    (diminish 'hungry-delete-mode)
    (diminish 'visual-line-mode)
    (diminish 'subword-mode)
    (diminish 'beacon-mode)
    (diminish 'irony-mode)
    (diminish 'page-break-lines-mode)
    (diminish 'auto-revert-mode)
    (diminish 'rainbow-delimiters-mode)
    (diminish 'rainbow-mode)
    (diminish 'yas-minor-mode)
    (diminish 'flycheck-mode)
    (diminish 'helm-mode))
#+END_SRC
* Instant messaging
I like IRC, I also like other protocols but I enjoy IRC most, it's obvious that I long
for a way to do my messaging from within emacs.
There is plenty of IRC clients in the repositories, and some more in the emacs repositories
but I find that the default =erc= does the job best, it's easy to use and offers some conveniences
that more sophisticated ones don't, so I use it.

** erc, also known as "a way to ask for help on #emacs"
You might want to edit the default nick, it's password protected anyway so don't bother.

*** Some common settings
This also hides some of the channel messages to avoid cluttering the buffer.
The other line changes the prompt for each channel buffer to match the channel name,
this way you always know who you are typing to.
#+BEGIN_SRC emacs-lisp
  (setq erc-nick "daedreth")
  (setq erc-prompt (lambda () (concat "[" (buffer-name) "]")))
  (setq erc-hide-list '("JOIN" "PART" "QUIT"))
#+END_SRC

*** Poor mans selectable server list
What it says on the tin, this changes the =erc= history to include the server I connect to often.
#+BEGIN_SRC emacs-lisp
  (setq erc-server-history-list '("irc.freenode.net"
                                  "localhost"))
#+END_SRC

*** Nick highlighting
You can even highlight nicks to make the buffers a bit more visually pleasing and easier to look at.
#+BEGIN_SRC emacs-lisp
(use-package erc-hl-nicks
  :ensure t
  :config
    (erc-update-modules))
#+END_SRC

** rich presence for discord
Memes, but it's fun and tiny.
#+BEGIN_SRC emacs-lisp
  (use-package elcord
    :ensure t)
#+END_SRC
* Wallpaper 
#+begin_src emacs-lisp
;; This is an example `use-package' configuration
;; It is not tangled into wallpaper.el
;(use-package wallpaper
 ; :ensure t
 ; :hook ((exwm-randr-screen-change . wallpaper-set-wallpaper)
 ;        (after-init . wallpaper-cycle-mode))
 ; :custom ((wallpaper-cycle-single t)
 ;          (wallpaper-scaling 'scale)
 ;          (wallpaper-cycle-interval 4500)
 ;          (wallpaper-cycle-directory "/usr/share/backgrounds")))
#+end_src

Ensure that you have ~feh~ installed before use.
#+begin_src emacs-lisp
;(unless (executable-find "feh")
;  (display-warning 'wallpaper "External command `feh' not found!"))
#+end_src
This package also uses functions that are not compatible with versions of Emacs before 25.
#+begin_src emacs-lisp
;(require 'cl-lib)
#+end_src
* Undo-tree
1) Press C-/ to undo, C-shift-/ to redo
2) press C-x u to bring up the ~undo-tree~.
#+begin_src emacs-lisp
  (use-package undo-tree
    :ensure t
    :init
    (global-undo-tree-mode))
#+end_src
* Volume
  C-x / + to increase volume by 10%
  c-x / - to decrease volume by 10%
  c-x / v to manually select a volume
  c-x / d to see the volume of the current sink
[[https://github.com/flexibeast/pulseaudio-control][Github documnetation]]
#+begin_src emacs-lisp
(require 'pulseaudio-control)
(pulseaudio-control-default-keybindings)
#+end_src
* Open a file with sudo access
s-e (sudo-edit)
* File Bookmarking in emacs
  [[http://pragmaticemacs.com/emacs/use-bookmarks-to-jump-to-files-or-directories/][Guide.]]
C-x r m -> Make a new bookmark
C-x r b -> Go to a bookmark
C-x r l -> List all bookmarks
* multi-vterm
- multi-vterm-project: Create/toggle terminal based on current project
- multi-vterm: Create a new terminal

#+begin_src emacs-lisp
(use-package multi-vterm)
#+end_src
* Current workspace number in modeline
#+begin_src emacs-lisp
;(setq mode-line-format (format "Workspace: %d " exwm-workspace-current-index))
;(message "Current workspace: %d" mode-line-format)
;(message "The value of fill-column is %d." fill-column)
;(force-mode-line-update t)

(defun abj/show-current-workspace()
  (message (format "Current Workspace: %d" exwm-workspace-current-index))
  (setq global-mode-string (last global-mode-string 1))
  (add-to-list 'global-mode-string (format "Workspace: %d " exwm-workspace-current-index))
  (force-mode-line-update t)
)
(add-hook 'exwm-workspace-switch-hook #'abj/show-current-workspace)
#+end_src
* INCOMPLETE Quelpa
I don't know why this is necessary.
#+begin_src emacs-lisp
;(quelpa
; '(quelpa-use-package
;   :fetcher git
;   :url "https://github.com/quelpa/quelpa-use-package.git"))
;(require 'quelpa-use-package)
#+end_src
** Bufler
 #+begin_src emacs-lisp
 ;(use-package bufler
 ;  :quelpa (bufler :fetcher github :repo "alphapapa/bufler.el"
 ;                  :files (:defaults (:exclude "helm-bufler.el"))))
; (use-package bufler)
 #+end_src
* INCOMPLETE Make buffer-list relate to workspace
#+begin_src emacs-lisp
;(exwm-workspace--display-buffer "*scratch*" display-buffer-alist)
;(buffer-list)
;(frame-face-alist)
#+end_src
* Eww mode
[[http://ergoemacs.org/emacs/emacs_eww_web_browser.html][Perfect Guide.]]
Following code opens url in new buffer. I still don't know why this is necessary.
#+begin_src emacs-lisp
(when (fboundp 'eww)
  (defun xah-rename-eww-buffer ()
    "Rename `eww-mode' buffer so sites open in new page.
URL `http://ergoemacs.org/emacs/emacs_eww_web_browser.html'
Version 2017-11-10"
    (let (($title (plist-get eww-data :title)))
      (when (eq major-mode 'eww-mode )
        (if $title
            (rename-buffer (concat "eww " $title ) t)
          (rename-buffer "eww" t)))))

  (add-hook 'eww-after-render-hook 'xah-rename-eww-buffer))
#+end_src
* Copy-paste in browser/application
~Toggle between char-mode and line-input-mode in exwm~
EXWM has three modes. They are- 
1) char mode : The app gets all the keyboard signals, aside from global keybindings. In this mode, we can freely use C-c to copy, C-x to cut C-v to paste etc.
2) line mode : EXWM gets all the keys.
3) simulation mode : Its a extension of line mode. EXWM gets the keybinding, then converts it and transfers it to the app. For example, 
#+begin_src emacs-lisp :eval never-export :results none :exports none
;; Don't run/evaluate or export this code block.
(exwm-input-set-simulation-keys
 '(([?\C-b] . left)
  ([?\C-f] . right)))
#+end_src

Now if we press C-f, EXWM will take that and convert it into "go to right character" and send it to app( e.g. firefox).
** Set global key to toggle between char-mode and line-mode
Press s-i to toggle between char-mode and line-mode
The following code does not work for some unknown reason. So in the meantime, use ~exwm-reset~ to go back to normal state of emacs. The keybinding for it is - ~s-r~
 #+begin_src emacs-lisp
(exwm-input-set-key (kbd "s-i") 'exwm-input-toggle-keyboard)
#+end_src

#+RESULTS:

** Open applications in char-mode by default
    I got this code block from [[https://emacs.stackexchange.com/questions/33326/how-do-i-cut-and-paste-effectively-between-applications-while-using-exwm][this stackoverflow question.]]
#+begin_src emacs-lisp
(add-hook 'exwm-manage-finish-hook
  (lambda () (call-interactively #'exwm-input-release-keyboard)
     ;(exwm-layout-hide-mode-line)
))
#+end_src
* Save emacs sessions
  Automatically save and load desktop sessions when exit/starting.
#+begin_src emacs-lisp
;(desktop-save-mode 1)
#+end_src
* Fresh Emacs with no auto-loaded sessions
  Specify the option ~--no-desktop~ on the command line when you don’t want it to reload any saved desktop. This turns off desktop-save-mode for the current session.
  
[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Emacs-Sessions.html][More here.]]
* Projectile
#+begin_src emacs-lisp
(use-package projectile)
(projectile-mode +1)
;; Recommended keymap prefix on Windows/Linux
(define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
#+end_src

#+RESULTS:
: projectile-command-map
* Auto-completion for text
We have auto-completion for programming languages. But how about texts?
The following code uses words from ~~/.emacs.d/misc/english-word.txt~  to perform auto-completion.
[[https://emacs.stackexchange.com/questions/18304/optimal-settings-for-auto-complete-for-writing-papers-prose-in-natural-languag][Source.]]
#+begin_src emacs-lisp
(require 'company)
(add-hook 'after-init-hook 'global-company-mode)

(defun text-mode-hook-setup ()
  ;; make `company-backends' local is critcal
  ;; or else, you will have completion in every major mode, that's very annoying!
  (make-local-variable 'company-backends)

  ;; company-ispell is the plugin to complete words
  (add-to-list 'company-backends 'company-ispell)

  ;; OPTIONAL, if `company-ispell-dictionary' is nil, `ispell-complete-word-dict' is used
  ;;  but I prefer hard code the dictionary path. That's more portable.
  (setq company-ispell-dictionary (file-truename "~/.emacs.d/misc/english-words.txt")))

(add-hook 'text-mode-hook 'text-mode-hook-setup)

#+end_src

#+RESULTS:
| text-mode-hook-setup | text-mode-hook-identify |
** Small Fix
Company mode eats up the ~space~ key so this small function saves us.
[[https://emacs.stackexchange.com/questions/56374/how-could-i-abort-and-apply-space-when-company-suggests-completion][Source.]]
#+begin_src emacs-lisp
(defun company-abort-and-insert-space ()
  (interactive)
  (company-abort)
  (insert " "))

(define-key company-active-map (kbd "SPC") #'company-abort-and-insert-space)
#+end_src

#+RESULTS:
: company-abort-and-insert-space
* Add keybinding to counsel-linux-app
#+begin_src emacs-lisp
  (exwm-input-set-key (kbd "s-a") 'counsel-linux-app)
#+end_src
* Video recording and screenshots
[[https://www.mattduck.com/2021-06-exwm-screenshots.html][Awesome guide.]]

These functions are bounded to keys-
Super-Shift-4
Super-Shift-5
Super-Shift-6
They are loaded when exwm is being loaded. So go to that configuration for their implmenetattion.

#+begin_src emacs-lisp
(defun md/screenshot-image-selection ()
  (interactive)
  (shell-command "/home/abhijit/manual-installation/,screenshot.sh --image-selection"))

(defun md/screenshot-video-selection-start ()
  (interactive)
  (shell-command "/home/abhijit/manual-installation/,screenshot.sh --video-selection-start"))

(defun md/screenshot-video-stop ()
  (interactive)
  (shell-command "/home/abhijit/manual-installation/,screenshot.sh --video-stop"))
#+end_src

#+RESULTS:
: md/screenshot-video-stop

#+RESULTSi
: ((sc-r-i . md/screenshot-image-selection) (sc-r-v . md/screenshot-video-selection-start) (sc-r-s . md/screenshot-video-stop))
* WILL_WORK_ON_IT Letterbox mode for censoring
[[https://github.com/pacha64/letterbox-mode][Source.]]
#+begin_src emacs-lisp
;(require 'letterbox-mode.el)
#+end_src
* WILL_WORK_ON_IT Define a set of keybinding
also, try regular use-package. the only issue is - setting multi-character keybinding like c-c s a
https://github.com/noctuid/general.el
#+begin_src emacs-lisp
#+end_src
* WILL_WORK_ON_IT Kill-ring
* List all keybindings available in a given buffer
C-h b
* Don't use arrow keys!
  The code is not really here, they are added in the section when vim is being initialized. So go to the part where we intialize evil-mode.

#+begin_src emacs-lisp

#+end_src
